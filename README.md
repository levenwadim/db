# db by leven
Mini ORM для Python 3

**Классы:**

- Db - Класс соединения с базой данных
- Model - Класс описывающий таблицу базы данных
- Column - Класс описывающий столбец (поле) таблицы

**Типы столбцов (полей):**

- Integer
- String(обязательная_длина)
- TEXT
- Enum
- DECIMAL(обязательная_длина, кол_во_знаков_после_запятой)
- DateTime
- Date

**Свойства столбцов (полей):**

- Свойства объекта Column
- primary_key (True/False, по умолчанию False)
- foreign_key (объект Column другого объекта Model, по умолчанию None)
- nullable (True/False, по умолчанию True, при наличии primary_key=True становится False)
- default (Любое значение/lambda-функцию, по умолчанию None) * Если значение по умолчанию вычисляется, например текущая дата, необходимо значение оборачивать в lambda-функцию (default=lambda: datetime.now()). Иначе при каждом создании объекта модели не будет вычислено новое значение

# Примеры использования

**Подключение к базе данных:**
```python
db = Db(host='127.0.0.1', user='root' name='database', passwd='123456')
```
Свойство echo=True - позволит видеть все осуществляемые запросы к базе данных


**Создание модели таблицы базы данных:**
```python
TypeNotification = Model('type_notification', db, 
  id = Column(Integer, primary_key=True),
  name = Column(String(255), nullable=False),
)
```


**Добавление статического метода в модель:**
```python
def func(x):
	print(x)
TypeNotification.add_staticmethod(func, 'func_name') # Если не указать название функции, возьмет название переданной функции
```
*Далее в коде*
```python
TypeNotification.func_name(2)
TypeNotification().func_name(2) # Не сработает, так как вызывается уже не как статическая функция
```

**Добавление метода в модель:**
```python
def func(self, x):
	print(self.name + x)
TypeNotification.add_method(func, 'func_name') # Если не указать название функции, возьмет название переданной функции
```
*Далее в коде*
```python
TypeNotification(name='Man').func_name(2)
TypeNotification.func_name(2) # Не сработает, так как вызывается как статическая функция
```

**Выборка всех строк в таблице:**
```python
Model.all()
```
**Выборка первой строки в таблице:**
```python
Model.first()
```
**Выборка строки по указанному при объявлении модели primary_key:**
```python
Model.get(значение_primary_key_поля)
```

**Фильтрация строк по указанным полям (условие AND) из таблицы:**
```python
Model.filter_by(поле1=значение1, поле2=значение2).нужная_выборка()
```
*Нужная выборка одна из списка ниже*
- .all()
- .first()
- .count()
- .exist()


**Получение кол-ва строк в таблице:**
```python
Model.count()
```
**Проверка наличие строк в таблице:**
```python
Model.exist()
```

**Добавление новой строки в таблицу:**
```python
Model(поле=значение).append()
```

**Обновление строки/строк в таблице:**
```python
object_of_model.update(поле1=значение1, поле2=значение) # Если не передан фильтр, в запросе будет использовать значение поля primary_key
Model.filter_by(hide=YesNoEnum.y).update(hide=YesNoEnum.n)
```

**Удаление строки/строк из таблицы:**
```python
object_of_model.delete() # Если не передан фильтр, в запросе будет использовать значение поля primary_key
Model.filter_by(hide=YesNoEnum.y).delete()
```


# Результаты запросов

- Тип результата любого запроса по умолчанию в dict (для скорости выполнения), т.е. использование model['название_поля']
- Для записи результата запроса в поля модели необходимо передать параметр orm=True в вызове функции
например, Model.get(1, orm=True) и далее в коде model.название_поля
не рекомендуется использовать orm при выборке списка строк - страдает производительность
- Для оптимизации запросов можно передавать список полей в виде название_поля=True, таким образом в результатах будут возвращены только данные по этим полям, а не по всем
например, Model.get(1, name=True, desc=True)